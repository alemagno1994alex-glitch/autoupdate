name: Aggiorna Playlist XromTV
on:
  schedule:
    # Esecuzioni agli orari italiani
    # Durante ora solare (ottobre-marzo): UTC+1
    - cron: '30 11 * * *'  # 12:30 ora italiana
    - cron: '0 14 * * *'   # 15:00 ora italiana
    - cron: '0 17 * * *'   # 18:00 ora italiana
    - cron: '45 19 * * *'  # 20:45 ora italiana
    - cron: '0 23 * * *'   # 00:00 ora italiana - reset
    # Durante ora legale (aprile-settembre): UTC+2
    - cron: '30 10 * 4-9 *'  # 12:30 ora italiana (estate)
    - cron: '0 13 * 4-9 *'   # 15:00 ora italiana (estate)
    - cron: '0 16 * 4-9 *'   # 18:00 ora italiana (estate)
    - cron: '45 18 * 4-9 *'  # 20:45 ora italiana (estate)
    - cron: '0 22 * 4-9 *'   # 00:00 ora italiana (estate) - reset
  workflow_dispatch:

permissions:
  contents: read

jobs:
  update-gist:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
      - name: Scarica playlist da XromTV con retry
        id: download
        run: |
          MAX_RETRIES=3
          RETRY_DELAY=30
          
          for i in $(seq 1 $MAX_RETRIES); do
            echo "üîÑ Tentativo $i di $MAX_RETRIES..."
            
            HTTP_CODE=$(curl -s -o new_playlist.m3u -w "%{http_code}" \
              --connect-timeout 30 \
              --max-time 60 \
              -H "User-Agent: GitHubAction-PlaylistUpdater/1.0" \
              -H "Accept: application/x-mpegURL, text/plain, */*" \
              https://xromtv.com/italia/player/eventi)
            
            if [ "$HTTP_CODE" = "200" ]; then
              echo "‚úÖ Download completato con successo"
              echo "success=true" >> $GITHUB_OUTPUT
              break
            elif [ "$HTTP_CODE" = "429" ]; then
              echo "‚ö†Ô∏è Rate limit raggiunto (429)"
              if [ $i -lt $MAX_RETRIES ]; then
                echo "‚è≥ Attendo ${RETRY_DELAY} secondi prima di ritentare..."
                sleep $RETRY_DELAY
                RETRY_DELAY=$((RETRY_DELAY * 2))
              else
                echo "‚ùå Tutti i tentativi falliti"
                echo "success=false" >> $GITHUB_OUTPUT
                exit 1
              fi
            else
              echo "‚ùå Errore HTTP: $HTTP_CODE"
              echo "success=false" >> $GITHUB_OUTPUT
              exit 1
            fi
          done

      - name: Verifica file scaricato
        run: |
          if [ ! -s new_playlist.m3u ]; then
            echo "‚ùå File new_playlist.m3u vuoto o non esistente"
            exit 1
          fi
          
          FILE_SIZE=$(wc -c < new_playlist.m3u)
          echo "üìä Dimensione file: $FILE_SIZE bytes"
          
          # Verifica dimensione minima ragionevole (es. 50 bytes)
          if [ $FILE_SIZE -lt 50 ]; then
            echo "‚ö†Ô∏è File sospettosamente piccolo"
            exit 1
          fi
          
          # Conta i canali
          NEW_COUNT=$(grep -c "^#EXTINF" new_playlist.m3u 2>/dev/null || echo 0)
          echo "üì∫ Canali scaricati: $NEW_COUNT"
          
          if [ $NEW_COUNT -eq 0 ]; then
            echo "‚ùå Nessun canale trovato nel file M3U"
            exit 1
          fi

      - name: Scarica M3U esistente dal Gist
        id: download_existing
        continue-on-error: true
        run: |
          echo "üì• Tentativo di scaricare M3U esistente dal Gist..."
          
          GIST_URL="https://gist.githubusercontent.com/${{ github.repository_owner }}/${{ secrets.GIST_ID }}/raw/eventi.m3u"
          
          if curl -s -f -o existing.m3u "$GIST_URL"; then
            echo "‚úÖ M3U esistente scaricato"
            
            CHANNEL_COUNT=$(grep -c "^#EXTINF" existing.m3u 2>/dev/null || echo 0)
            echo "üìä Canali esistenti: $CHANNEL_COUNT"
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "‚ÑπÔ∏è Nessun M3U esistente (primo run o Gist vuoto)"
            echo "exists=false" >> $GITHUB_OUTPUT
            touch existing.m3u
          fi

      - name: Processa e aggiorna M3U
        run: |
          # Rileva automaticamente fuso orario italiano (gestisce ora legale/solare)
          CURRENT_HOUR=$(TZ='Europe/Rome' date +%H)
          CURRENT_MINUTE=$(TZ='Europe/Rome' date +%M)
          CURRENT_DATE=$(TZ='Europe/Rome' date '+%Y-%m-%d %H:%M:%S %Z')
          
          echo "üïê Ora corrente italiana: ${CURRENT_HOUR}:${CURRENT_MINUTE}"
          echo "üìÖ Data completa: ${CURRENT_DATE}"
          
          # Funzione per estrarre l'identificatore univoco del canale
          extract_channel_id() {
            local line="$1"
            # Usa il nome del canale (dopo l'ultima virgola) come ID
            echo "$line" | sed -n 's/.*,\s*\(.*\)/\1/p'
          }
          
          # Funzione per estrarre l'intero blocco canale (EXTINF + KODIPROP + URL)
          extract_channel_block() {
            local start_line=$1
            local file=$2
            local output_file=$3
            
            tail -n +$start_line "$file" | awk '
              BEGIN { in_block=1 }
              /^#EXTINF/ { 
                if (NR > 1) exit
                print
                next
              }
              /^#EXT-X-PLAYLIST-TYPE/ { print; next }
              /^#KODIPROP/ { print; next }
              /^https?:/ { 
                print
                in_block=0
                exit
              }
              in_block { print }
            ' >> "$output_file"
          }
          
          # A MEZZANOTTE (00:00): Reset completo - SVUOTA la playlist
          if [ "$CURRENT_HOUR" == "00" ] && [ "$CURRENT_MINUTE" -lt "10" ]; then
            echo "üåô MEZZANOTTE - Reset completo: ELIMINO tutti i canali"
            
            # Crea playlist vuota con solo header
            echo "#EXTM3U" > merged.m3u
            
            echo "‚úÖ Playlist svuotata - I nuovi canali verranno inseriti alle 12:30"
            
            echo "OLD_COUNT=0" >> $GITHUB_ENV
            echo "NEW_ADDED=0" >> $GITHUB_ENV
            echo "UPDATED=0" >> $GITHUB_ENV
            echo "FINAL_COUNT=0" >> $GITHUB_ENV
            echo "RESET=true" >> $GITHUB_ENV
            
          # PRIMO INSERIMENTO ALLE 12:30 dopo il reset di mezzanotte
          elif [ "$CURRENT_HOUR" == "12" ] && [ "$CURRENT_MINUTE" -ge "25" ] && [ "$CURRENT_MINUTE" -le "35" ]; then
            echo "üåÖ ORE 12:30 - Primo caricamento giornaliero da XromTV"
            
            cp new_playlist.m3u merged.m3u
            
            FINAL_COUNT=$(grep -c "^#EXTINF" merged.m3u 2>/dev/null || echo 0)
            echo "‚úÖ Caricati $FINAL_COUNT nuovi canali per oggi"
            
            echo "OLD_COUNT=0" >> $GITHUB_ENV
            echo "NEW_ADDED=$FINAL_COUNT" >> $GITHUB_ENV
            echo "UPDATED=0" >> $GITHUB_ENV
            echo "FINAL_COUNT=$FINAL_COUNT" >> $GITHUB_ENV
            echo "RESET=false" >> $GITHUB_ENV
            echo "FIRST_LOAD=true" >> $GITHUB_ENV
            
          else
            # AGGIORNAMENTO NORMALE (15:00, 18:00, 20:45)
            echo "üîÑ Aggiornamento playlist agli orari programmati (15:00, 18:00, 20:45)"
            
            # Inizia con l'header
            echo "#EXTM3U" > merged.m3u
            
            # Array associativo per tracciare canali
            declare -A channel_map
            declare -A channel_line_map
            
            # FASE 1: Carica canali esistenti
            echo "üì∫ Fase 1: Carico canali esistenti..."
            OLD_COUNT=0
            
            if [ -s existing.m3u ]; then
              line_num=0
              while IFS= read -r line; do
                line_num=$((line_num + 1))
                
                if [[ $line == "#EXTINF"* ]]; then
                  channel_id=$(extract_channel_id "$line")
                  
                  if [ ! -z "$channel_id" ]; then
                    channel_map[$channel_id]="existing"
                    channel_line_map[$channel_id]=$line_num
                    OLD_COUNT=$((OLD_COUNT + 1))
                  fi
                fi
              done < existing.m3u
              
              echo "‚úÖ Trovati $OLD_COUNT canali esistenti"
            fi
            
            # FASE 2: Processa nuovi canali e aggiorna/aggiungi
            echo "üÜï Fase 2: Processo nuovi canali da XromTV..."
            NEW_ADDED=0
            UPDATED=0
            
            line_num=0
            while IFS= read -r line; do
              line_num=$((line_num + 1))
              
              if [[ $line == "#EXTINF"* ]]; then
                channel_id=$(extract_channel_id "$line")
                
                if [ ! -z "$channel_id" ]; then
                  if [ -z "${channel_map[$channel_id]}" ]; then
                    # Nuovo canale
                    echo "‚ûï Nuovo canale: $channel_id"
                    channel_map[$channel_id]="new"
                    NEW_ADDED=$((NEW_ADDED + 1))
                  else
                    # Canale esistente - aggiorna URL
                    echo "üîÑ Aggiorno URL per: $channel_id"
                    UPDATED=$((UPDATED + 1))
                  fi
                  
                  # Aggiungi separatore
                  echo "" >> merged.m3u
                  
                  # Estrai e scrivi il blocco completo del canale
                  tail -n +$line_num new_playlist.m3u | awk '
                    BEGIN { in_block=1; first_extinf=1 }
                    /^#EXTINF/ { 
                      if (!first_extinf) exit
                      first_extinf=0
                      print
                      next
                    }
                    /^#EXT-X-PLAYLIST-TYPE/ { print; next }
                    /^#KODIPROP/ { print; next }
                    /^https?:/ { 
                      print
                      print ""
                      exit
                    }
                    /^$/ { next }
                    in_block { print }
                  ' >> merged.m3u
                fi
              fi
            done < new_playlist.m3u
            
            FINAL_COUNT=$((NEW_ADDED + UPDATED))
            echo "‚úÖ Totale canali: $FINAL_COUNT (nuovi: $NEW_ADDED, aggiornati: $UPDATED)"
            
            echo "OLD_COUNT=$OLD_COUNT" >> $GITHUB_ENV
            echo "NEW_ADDED=$NEW_ADDED" >> $GITHUB_ENV
            echo "UPDATED=$UPDATED" >> $GITHUB_ENV
            echo "FINAL_COUNT=$FINAL_COUNT" >> $GITHUB_ENV
            echo "RESET=false" >> $GITHUB_ENV
          fi
          
          # Pulizia finale
          sed -i '/^$/N;/^\n$/d' merged.m3u  # Rimuovi righe vuote doppie
          
          # Verifica finale
          echo "üìã Verifica finale M3U:"
          echo "- Canali totali: $FINAL_COUNT"
          echo "- Dimensione file: $(wc -c < merged.m3u) bytes"
          echo "- Prime 10 righe:"
          head -n 10 merged.m3u

      - name: Ripristina hash precedente dalla cache
        id: cache
        uses: actions/cache@v4
        with:
          path: last_hash.txt
          key: playlist-hash-${{ github.run_id }}
          restore-keys: |
            playlist-hash-

      - name: Calcola hash e verifica cambiamenti
        id: check
        run: |
          NEW_HASH=$(sha256sum merged.m3u | awk '{print $1}')
          echo "üî¢ Nuovo hash (SHA-256): $NEW_HASH"
          
          if [ -f last_hash.txt ]; then
            OLD_HASH=$(cat last_hash.txt)
            echo "üî¢ Vecchio hash: $OLD_HASH"
          else
            OLD_HASH="none"
            echo "‚ÑπÔ∏è Primo run - nessun hash precedente"
          fi
          
          if [ "$NEW_HASH" != "$OLD_HASH" ]; then
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Rilevati cambiamenti - Aggiornamento Gist..."
            echo "$NEW_HASH" > last_hash.txt
          else
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è Nessun cambiamento - Skip aggiornamento"
          fi
          
          echo "new_hash=$NEW_HASH" >> $GITHUB_OUTPUT

      - name: Aggiorna Gist
        if: steps.check.outputs.changed == 'true'
        uses: exuanbo/actions-deploy-gist@v1
        with:
          token: ${{ secrets.GIST_TOKEN }}
          gist_id: ${{ secrets.GIST_ID }}
          file_path: merged.m3u
          file_type: text

      - name: Notifica su fallimento
        if: failure()
        run: |
          echo "::error::‚ùå Workflow fallito - controllare i log"

      - name: Riepilogo finale
        if: always()
        run: |
          echo "### üìä Riepilogo Esecuzione" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Parametro | Valore |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Hash playlist** | \`${{ steps.check.outputs.new_hash }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Cambiamenti** | ${{ steps.check.outputs.changed == 'true' && '‚úÖ S√¨' || '‚è≠Ô∏è No' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Ora esecuzione (Italia)** | $(TZ='Europe/Rome' date '+%Y-%m-%d %H:%M:%S') |" >> $GITHUB_STEP_SUMMARY
          echo "| **Stato** | ${{ job.status == 'success' && '‚úÖ Successo' || '‚ùå Fallito' }} |" >> $GITHUB_STEP_SUMMARY
          
          if [ -f merged.m3u ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**üìè Statistiche Aggiornamento:**" >> $GITHUB_STEP_SUMMARY
            
            if [ "${RESET}" == "true" ]; then
              echo "- üåô **RESET MEZZANOTTE ESEGUITO** - Playlist svuotata" >> $GITHUB_STEP_SUMMARY
              echo "- ‚è∞ Prossimo caricamento: **domani alle 12:30**" >> $GITHUB_STEP_SUMMARY
            elif [ "${FIRST_LOAD}" == "true" ]; then
              echo "- üåÖ **PRIMO CARICAMENTO GIORNALIERO (12:30)**" >> $GITHUB_STEP_SUMMARY
              echo "- üì∫ Canali caricati: ${FINAL_COUNT}" >> $GITHUB_STEP_SUMMARY
            else
              echo "- üì∫ Canali totali: ${FINAL_COUNT}" >> $GITHUB_STEP_SUMMARY
              echo "- üîÑ Canali precedenti: ${OLD_COUNT}" >> $GITHUB_STEP_SUMMARY
              echo "- ‚ûï Nuovi aggiunti: ${NEW_ADDED}" >> $GITHUB_STEP_SUMMARY
              echo "- üîÑ URL aggiornati: ${UPDATED}" >> $GITHUB_STEP_SUMMARY
            fi
            
            echo "- üíæ Dimensione: $(du -h merged.m3u | cut -f1)" >> $GITHUB_STEP_SUMMARY
            
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**‚è∞ Prossimi aggiornamenti (ora italiana - gestione automatica ora legale/solare):**" >> $GITHUB_STEP_SUMMARY
            echo "- üïß 12:30 - Primo caricamento dopo reset" >> $GITHUB_STEP_SUMMARY
            echo "- üïí 15:00 - Aggiornamento" >> $GITHUB_STEP_SUMMARY
            echo "- üïï 18:00 - Aggiornamento" >> $GITHUB_STEP_SUMMARY
            echo "- üïò 20:45 - Aggiornamento" >> $GITHUB_STEP_SUMMARY
            echo "- üåô 00:00 - Reset completo (svuota playlist)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "‚ÑπÔ∏è *Gli orari si adattano automaticamente all'ora legale/solare italiana*" >> $GITHUB_STEP_SUMMARY
          fi