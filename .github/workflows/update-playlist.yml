name: Aggiorna Playlist Gist
on:
  schedule:
    - cron: '0 */2 * * *' # Ogni 2 ore (12 volte al giorno)
  workflow_dispatch:

permissions:
  contents: read

jobs:
  update-gist:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
      - name: Scarica playlist dal Worker con retry
        id: download
        run: |
          MAX_RETRIES=3
          RETRY_DELAY=30
          
          for i in $(seq 1 $MAX_RETRIES); do
            echo "üîÑ Tentativo $i di $MAX_RETRIES..."
            
            HTTP_CODE=$(curl -s -o playlists.json -w "%{http_code}" \
              --connect-timeout 30 \
              --max-time 60 \
              -H "User-Agent: GitHubAction-PlaylistUpdater/1.0" \
              -H "Accept: application/json" \
              https://eventi.alemagno1994alex.workers.dev)
            
            if [ "$HTTP_CODE" = "200" ]; then
              echo "‚úÖ Download completato con successo"
              echo "success=true" >> $GITHUB_OUTPUT
              break
            elif [ "$HTTP_CODE" = "429" ]; then
              echo "‚ö†Ô∏è Rate limit raggiunto (429)"
              if [ $i -lt $MAX_RETRIES ]; then
                echo "‚è≥ Attendo ${RETRY_DELAY} secondi prima di ritentare..."
                sleep $RETRY_DELAY
                RETRY_DELAY=$((RETRY_DELAY * 2)) # Backoff esponenziale
              else
                echo "‚ùå Tutti i tentativi falliti"
                echo "success=false" >> $GITHUB_OUTPUT
                exit 1
              fi
            else
              echo "‚ùå Errore HTTP: $HTTP_CODE"
              echo "success=false" >> $GITHUB_OUTPUT
              exit 1
            fi
          done

      - name: Verifica file scaricato
        run: |
          if [ ! -s playlists.json ]; then
            echo "‚ùå File playlists.json vuoto o non esistente"
            exit 1
          fi
          
          # Verifica che sia JSON valido
          if ! jq empty playlists.json 2>/dev/null; then
            echo "‚ùå File JSON non valido"
            exit 1
          fi
          
          FILE_SIZE=$(wc -c < playlists.json)
          echo "üìä Dimensione file: $FILE_SIZE bytes"
          
          # Verifica dimensione minima ragionevole (es. 100 bytes)
          if [ $FILE_SIZE -lt 100 ]; then
            echo "‚ö†Ô∏è File sospettosamente piccolo"
            exit 1
          fi

      - name: Scarica M3U esistente dal Gist
        id: download_existing
        continue-on-error: true
        run: |
          echo "üì• Tentativo di scaricare M3U esistente dal Gist..."
          
          GIST_URL="https://gist.githubusercontent.com/${{ github.repository_owner }}/${{ secrets.GIST_ID }}/raw/merged.m3u"
          
          if curl -s -f -o existing.m3u "$GIST_URL"; then
            echo "‚úÖ M3U esistente scaricato"
            
            CHANNEL_COUNT=$(grep -c "^#EXTINF" existing.m3u 2>/dev/null || echo 0)
            echo "üìä Canali esistenti: $CHANNEL_COUNT"
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "‚ÑπÔ∏è Nessun M3U esistente (primo run o Gist vuoto)"
            echo "exists=false" >> $GITHUB_OUTPUT
            touch existing.m3u
          fi

      - name: Processa e aggiorna M3U (mantieni fino a mezzanotte)
        run: |
          echo "üì• Estrazione e concatenazione M3U dal JSON..."
          
          # Il JSON contiene array di oggetti con campo "text" che contiene M3U completi
          # Concatena tutti i "text" rispettando i newline (\n)
          jq -r '.[].text' playlists.json > new_channels.m3u
          
          # Rimuovi intestazioni #EXTM3U duplicate (mantieni solo la prima)
          # e righe vuote multiple
          awk 'BEGIN{first=1} /^#EXTM3U/{if(first){print; first=0; next} else next} /^$/{if(prev!=""){print; prev=""} next} {print; prev=$0}' new_channels.m3u > new_channels_clean.m3u
          mv new_channels_clean.m3u new_channels.m3u
          
          NEW_COUNT=$(grep -c "^#EXTINF" new_channels.m3u 2>/dev/null || echo 0)
          echo "üìù Nuovi canali dal Worker: $NEW_COUNT"
          
          if [ $NEW_COUNT -eq 0 ]; then
            echo "‚ùå Nessun canale nel JSON"
            exit 1
          fi
          
          # Orario corrente (UTC)
          CURRENT_HOUR=$(date -u +%H)
          echo "üïê Ora corrente UTC: ${CURRENT_HOUR}:00"
          
          # Funzione per estrarre l'identificatore univoco del canale
          extract_channel_id() {
            local line="$1"
            # Estrai il nome dopo l'ultima virgola come identificatore
            echo "$line" | sed -n 's/.*,\s*\(.*\)/\1/p'
          }
          
          # Se esiste un M3U precedente e non √® ancora mezzanotte
          if [ -f existing.m3u ] && [ -s existing.m3u ] && [ "$CURRENT_HOUR" != "00" ]; then
            echo "üîÑ Merge con canali esistenti (mantieni fino a mezzanotte)..."
            
            # Inizia con l'header #EXTM3U
            echo "#EXTM3U" > merged.m3u
            echo "" >> merged.m3u
            
            # Array associativo per tracciare canali gi√† inseriti
            declare -A processed_channels
            
            # FASE 1: Aggiungi tutti i canali esistenti
            echo "üì∫ Fase 1: Carico canali esistenti..."
            OLD_COUNT=0
            
            while IFS= read -r line; do
              # Salta header e righe vuote nella fase di lettura
              if [[ $line == "#EXTM3U"* ]] || [[ -z "$line" ]]; then
                continue
              fi
              
              if [[ $line == "#EXTINF"* ]]; then
                channel_id=$(extract_channel_id "$line")
                
                if [ ! -z "$channel_id" ] && [ -z "${processed_channels[$channel_id]}" ]; then
                  processed_channels[$channel_id]=1
                  OLD_COUNT=$((OLD_COUNT + 1))
                  
                  # Scrivi la entry completa (EXTINF + successive righe fino al prossimo EXTINF o EOF)
                  echo "$line" >> merged.m3u
                  
                  # Continua a leggere le righe successive fino al prossimo #EXTINF
                  while IFS= read -r next_line; do
                    if [[ $next_line == "#EXTINF"* ]]; then
                      # Torna indietro di una riga (la gestiremo nel loop principale)
                      echo "$next_line" | cat - > /tmp/pushback_line
                      break
                    fi
                    echo "$next_line" >> merged.m3u
                  done
                  
                  # Se c'√® una riga pushback, rimettila nel flusso
                  if [ -f /tmp/pushback_line ]; then
                    cat /tmp/pushback_line
                    rm /tmp/pushback_line
                  fi
                fi
              fi
            done < existing.m3u
            
            echo "‚úÖ Canali mantenuti: $OLD_COUNT"
            
            # FASE 2: Aggiungi nuovi canali
            echo "üÜï Fase 2: Aggiungo nuovi canali..."
            NEW_ADDED=0
            UPDATED=0
            
            while IFS= read -r line; do
              # Salta header e righe vuote
              if [[ $line == "#EXTM3U"* ]] || [[ $line == "#EXT-X-PLAYLIST-TYPE"* ]] || [[ -z "$line" ]]; then
                continue
              fi
              
              if [[ $line == "#EXTINF"* ]]; then
                channel_id=$(extract_channel_id "$line")
                
                if [ ! -z "$channel_id" ]; then
                  if [ -z "${processed_channels[$channel_id]}" ]; then
                    echo "‚ûï Nuovo: $channel_id"
                    processed_channels[$channel_id]=1
                    NEW_ADDED=$((NEW_ADDED + 1))
                    
                    # Aggiungi separatore
                    echo "" >> merged.m3u
                    
                    # Scrivi entry completa
                    echo "$line" >> merged.m3u
                    
                    # Continua a leggere fino al prossimo #EXTINF
                    while IFS= read -r next_line; do
                      if [[ $next_line == "#EXTINF"* ]]; then
                        echo "$next_line" | cat - > /tmp/pushback_line
                        break
                      fi
                      echo "$next_line" >> merged.m3u
                    done
                    
                    if [ -f /tmp/pushback_line ]; then
                      cat /tmp/pushback_line
                      rm /tmp/pushback_line
                    fi
                  else
                    UPDATED=$((UPDATED + 1))
                    # Salta questa entry (gi√† presente)
                    while IFS= read -r next_line; do
                      if [[ $next_line == "#EXTINF"* ]]; then
                        echo "$next_line" | cat - > /tmp/pushback_line
                        break
                      fi
                    done
                    
                    if [ -f /tmp/pushback_line ]; then
                      cat /tmp/pushback_line
                      rm /tmp/pushback_line
                    fi
                  fi
                fi
              fi
            done < new_channels.m3u
            
            FINAL_COUNT=$((OLD_COUNT + NEW_ADDED))
            echo "‚úÖ Totale canali: $FINAL_COUNT (mantenuti: $OLD_COUNT, nuovi: $NEW_ADDED, gi√† presenti: $UPDATED)"
            
            # Salva statistiche
            echo "OLD_COUNT=$OLD_COUNT" >> $GITHUB_ENV
            echo "NEW_ADDED=$NEW_ADDED" >> $GITHUB_ENV
            
          else
            # A mezzanotte (00:00 UTC) o primo run: usa solo i nuovi canali
            if [ "$CURRENT_HOUR" == "00" ]; then
              echo "üåô Mezzanotte UTC - Reset completo con nuovi canali"
            else
              echo "‚ÑπÔ∏è Primo run - Inizializzo con nuovi canali"
            fi
            
            cp new_channels.m3u merged.m3u
            FINAL_COUNT=$NEW_COUNT
            echo "OLD_COUNT=0" >> $GITHUB_ENV
            echo "NEW_ADDED=$NEW_COUNT" >> $GITHUB_ENV
          fi
          
          # Verifica finale
          echo "üìã Verifica finale M3U:"
          echo "- Canali totali: $FINAL_COUNT"
          echo "- Dimensione file: $(wc -c < merged.m3u) bytes"
          echo "- Prime 5 righe:"
          head -n 5 merged.m3u
          
          # Salva conteggio finale
          echo "FINAL_COUNT=$FINAL_COUNT" >> $GITHUB_ENV
          echo "NEW_COUNT=$NEW_COUNT" >> $GITHUB_ENV

      - name: Ripristina hash precedente dalla cache
        id: cache
        uses: actions/cache@v4
        with:
          path: last_hash.txt
          key: playlist-hash-${{ github.run_id }}
          restore-keys: |
            playlist-hash-

      - name: Calcola hash e verifica cambiamenti
        id: check
        run: |
          NEW_HASH=$(sha256sum merged.m3u | awk '{print $1}')
          echo "üî¢ Nuovo hash (SHA-256): $NEW_HASH"
          
          if [ -f last_hash.txt ]; then
            OLD_HASH=$(cat last_hash.txt)
            echo "üî¢ Vecchio hash: $OLD_HASH"
          else
            OLD_HASH="none"
            echo "‚ÑπÔ∏è Primo run - nessun hash precedente"
          fi
          
          if [ "$NEW_HASH" != "$OLD_HASH" ]; then
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Rilevati cambiamenti - Aggiornamento Gist..."
            echo "$NEW_HASH" > last_hash.txt
          else
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è Nessun cambiamento - Skip aggiornamento"
          fi
          
          echo "new_hash=$NEW_HASH" >> $GITHUB_OUTPUT

      - name: Aggiorna Gist
        if: steps.check.outputs.changed == 'true'
        uses: exuanbo/actions-deploy-gist@v1
        with:
          token: ${{ secrets.GIST_TOKEN }}
          gist_id: ${{ secrets.GIST_ID }}
          file_path: merged.m3u
          file_type: text

      - name: Notifica su fallimento (opzionale)
        if: failure()
        run: |
          echo "::error::‚ùå Workflow fallito - controllare i log"
          # Qui puoi aggiungere notifiche (Slack, Discord, email, etc.)

      - name: Riepilogo finale
        if: always()
        run: |
          echo "### üìä Riepilogo Esecuzione" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Parametro | Valore |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Hash playlist** | \`${{ steps.check.outputs.new_hash }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Cambiamenti** | ${{ steps.check.outputs.changed == 'true' && '‚úÖ S√¨' || '‚è≠Ô∏è No' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Ora esecuzione (UTC)** | $(date -u '+%Y-%m-%d %H:%M:%S') |" >> $GITHUB_STEP_SUMMARY
          echo "| **Prossimo reset** | $(date -u -d 'tomorrow 00:00' '+%Y-%m-%d 00:00 UTC') |" >> $GITHUB_STEP_SUMMARY
          echo "| **Stato** | ${{ job.status == 'success' && '‚úÖ Successo' || '‚ùå Fallito' }} |" >> $GITHUB_STEP_SUMMARY
          
          if [ -f merged.m3u ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**üìè Statistiche File:**" >> $GITHUB_STEP_SUMMARY
            echo "- üì∫ Canali totali: ${FINAL_COUNT:-N/A}" >> $GITHUB_STEP_SUMMARY
            echo "- üîÑ Mantenuti precedenti: ${OLD_COUNT:-0}" >> $GITHUB_STEP_SUMMARY
            echo "- ‚ûï Nuovi aggiunti: ${NEW_ADDED:-N/A}" >> $GITHUB_STEP_SUMMARY
            echo "- üÜï Dal Worker oggi: ${NEW_COUNT:-N/A}" >> $GITHUB_STEP_SUMMARY
            echo "- üíæ Dimensione: $(du -h merged.m3u | cut -f1)" >> $GITHUB_STEP_SUMMARY
            
            CURRENT_HOUR=$(date -u +%H)
            if [ "$CURRENT_HOUR" == "00" ]; then
              echo "- üåô **Reset mezzanotte eseguito**" >> $GITHUB_STEP_SUMMARY
            else
              echo "- ‚è∞ Prossimo reset tra $((24 - 10#$CURRENT_HOUR)) ore" >> $GITHUB_STEP_SUMMARY
            fi
          fi